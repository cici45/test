#include "ser.h"


bool ser::init(char portname[8], BYTE databits, BYTE stopbits, BYTE parity, DWORD baudrate) {
        string t;

        handlePort_ = new HANDLE ;

        config_= new DCB  ;

        config_->DCBlength=sizeof(DCB);
	//portname =new char ;


        * handlePort_ = CreateFile(portname, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);

	//this->portname = (*char)(portname);

      //	t = "Could not access " + this->portname + ".";


      if(* handlePort_ ==INVALID_HANDLE_VALUE)
      {
        return FALSE;
      };

     SetupComm(* handlePort_, 1024, 1024);

	if (GetCommState(*handlePort_,config_) == 0)
        {

 	        return FALSE;
        }

	config_->BaudRate = baudrate;
	config_->StopBits = stopbits;
	config_->Parity =parity;
	config_->ByteSize =databits;

	if (SetCommState(*handlePort_,config_) == 0)
        {
      DWORD AA=  GetLastError  ();
		return FALSE;
	}


       COMMTIMEOUTS comTimeOut;
        comTimeOut.ReadIntervalTimeout = 20;
        comTimeOut.ReadTotalTimeoutMultiplier = 20;
        comTimeOut.ReadTotalTimeoutConstant = 50;
        comTimeOut.WriteTotalTimeoutMultiplier = 50;
        comTimeOut.WriteTotalTimeoutConstant = 50;
        SetCommTimeouts(*handlePort_,&comTimeOut);

        return TRUE;
}


bool ser::write(string str, int length) {
	unsigned long l;
	string t;
       //	t = "Could not access " + portname + ".";

	if (WriteFile(*handlePort_, str.c_str(), length, &l, NULL) == 0) {
		return FALSE;
        }

	return TRUE;
}


unsigned int ser::write(unsigned char str[], int length) {
	unsigned long l;
	string t;
       //	t = "Could not access " + portname + ".";

	if (WriteFile(*handlePort_, str, length, &l, NULL) == 0)
        {
		return FALSE;
        }
	return TRUE;
}


bool ser::read(string *str, int length, unsigned long *lread) {
	char instring[256];
	string t;
       //	t = "Could not access " + portname + ".";

	if (ReadFile(*handlePort_, instring, length, lread, NULL) == 0) {
		return FALSE;
	}

	*str = instring;

	return TRUE;
}


unsigned int ser::read(unsigned char str[], int length, unsigned long *lread) {
	string t;
	//t = "Could not access " + portname + ".";

	if (ReadFile(*handlePort_, str, length, lread, NULL) == 0) {
		return FALSE;
	}

	return TRUE;
}


void  ser::Clear_Memory()
{

 PurgeComm(*handlePort_,PURGE_TXCLEAR|PURGE_RXCLEAR);
}


bool ser::close() {
	string t;
	//t = "Could not access " + portname + ".";
        if(!handlePort_)
        {
	if(CloseHandle(*handlePort_) == 0) {
		return FALSE;
        }
        }
	return TRUE;
}


bool ser::flush() {
	FlushFileBuffers(*handlePort_);

	return TRUE;
}